<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Beyond SELECT: Building a Real‑World Analytics Stack</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 2rem auto; line-height: 1.6; max-width: 900px; padding: 0 1rem; }
    h1, h2, h3 { line-height: 1.25; }
    code, pre { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    pre { background: rgba(127,127,127,0.12); padding: 0.75rem 1rem; border-radius: 8px; overflow-x: auto; }
    .note { border-left: 4px solid #0ea5e9; background: rgba(14,165,233,0.1); padding: 0.75rem 1rem; border-radius: 6px; }
    .meta { color: #64748b; font-size: 0.95rem; }
    a { color: #0ea5e9; text-decoration: none; }
    a:hover { text-decoration: underline; }
    ul { margin-left: 1.25rem; }
    hr { border: none; border-top: 1px solid rgba(127,127,127,0.25); margin: 2rem 0; }
  </style>
  <meta name="description" content="A friendly, hands-on guide to a modern analytics stack using PostgreSQL, dbt, Docker, and migrations—designed for learning and clarity." />
</head>
<body>

  <header>
    <h1>Beyond SELECT: Building a Real‑World Analytics Stack</h1>
    <p class="meta">6 min read • Analytics Engineering</p>
  </header>

  <p>There are resources for PostgreSQL, dbt, Docker, and migrations. Few cover how to combine them into a real pipeline. This project is a scaffold you can run locally to see how raw data becomes analytics-ready tables—using the right tool at the right layer, as discussed in <em>Beyond SELECT: SQL as a Full Development Platform</em> (<a href="https://www.megpatakota.co.uk/articles/sql-beyond-select.html" target="_blank" rel="noopener noreferrer">link</a>).</p>

  <p>It’s not a 101. It ties concepts into a single structure.</p>

  <hr />

  <h2>Why This Matters: The Production Reality</h2>

  <p>You'll hit this pattern on any data project: ingest raw data, clean/transform it, and roll analytics-ready tables. The design choice is whether it scales and stays maintainable.</p>

  <p>In practice, most teams stumble because raw and analytics layers blur, tests are missing, and changes are brittle. The result is slow dashboards, bugs, late detections, and ad-hoc SQL that compounds complexity.</p>

  <p>That’s why this project exists: a minimal reference built for clarity and reproducibility in production.</p>

  <hr />

  <h2>What's inside (and why)</h2>

  <h3>Three Layers, Each with a Job</h3>

  <p><strong>Raw:</strong> Postgres tables with constraints for integrity. No business logic.</p>
  <p><strong>Staging:</strong> Views that clean and standardize. Naming conventions and type casting.</p>
  <p><strong>Marts:</strong> Denormalized, indexed tables for BI.</p>

  <p>Why layers: fixes to Raw don’t cascade; Staging is testable; Marts stay fast without touching raw data.</p>

  <h3>Production Choices You'll Face</h3>

  <p><strong>Migrations for schema changes:</strong> Create and recreate environments reliably; version safely.</p>
  <p><strong>dbt for transformations:</strong> Modular, tested, documented; lineage included.</p>
  <p><strong>Docker for reproducibility:</strong> Drops "works on my machine".</p>
  <p><strong>Separation of concerns:</strong> DB rules, staging logic, marts for BI. Reduces coupling.</p>

  <hr />

  <h2>Where Production Hits Reality</h2>

  <p>Here's what nobody tells you about production-grade data pipelines: that incremental model that runs in 2 seconds on your laptop with 10,000 rows will timeout after 30 minutes in production with 50 million rows. And your dashboard users will absolutely notice.</p>

  <p>The project covers the production techniques that actually matter:</p>

  <h3>Incremental Models: Your Insurance Policy Against Timeouts</h3>
  <p>Example: <code>fact_sales</code> uses dbt incremental materialization to process only new rows since the last run. Maintains indexes automatically.</p>
  <p>In production, you can't just full refresh everything when it gets big. Incremental updates are essential. The alternative is overnight jobs that fail at 3am.</p>

  <h3>Indexes: Where Theory Meets Query Plans</h3>
  <p>Add them on keys, dates, and frequently filtered columns. Trade write cost for query speed.</p>
  <p>The catch: every index slows down writes a little bit. Find the balance. Production systems that actually work have this figured out from day one.</p>

  <h3>Maintenance That Happens Automatically</h3>
  <p>A service runs <code>VACUUM (ANALYZE)</code> after transformations to keep stats fresh, avoid bloat, and ensure the query planner isn't lying to you.</p>
  <p>Without it, your queries get slower over time even if the data hasn't changed much. Production systems that don't collapse six months in run maintenance automatically.</p>

  <h3>Tests: Yes, You Actually Need Them</h3>
  <p>dbt tests catch nulls and duplicates before your users do. The databases that don't have downstream analytics teams yelling at you are the ones where someone wrote tests.</p>
  <p>This doesn't mean you need a full testing framework day one, but if your transformations aren't tested, they're not production-grade.</p>

  <h3>Resource Management</h3>
  <p>Docker resource limits prevent one service from killing the others. Postgres memory tuning prevents OOM crashes when those multi-join queries happen.</p>

  <h3>Guarantees When Things Break</h3>
  <p>Migrations are transactional. If a schema change fails halfway through, it rolls back—no half-broken tables.</p>
  <p>Environment files keep credentials out of code. The <code>.env</code> file is ignored, and the template shows what's needed without exposing secrets.</p>
  <p>dbt's dependency graph means if staging fails, marts don't even try to run. You won't end up with partially refreshed data that makes your numbers look completely wrong.</p>

  <h3>Data Quality Checks</h3>
  <p>Constraints in raw tables reject invalid data at the source: negative prices, null SKUs, out-of-range dates.</p>
  <p>Tests catch logic errors before they hit production: duplicate keys, missing joins, aggregation mistakes.</p>
  <p>Incremental models only process records newer than the last successful run. If you have late-arriving data, you can re-run just the recent window without reprocessing everything.</p>
  <p>If something does fail, Docker volumes persist your data. A broken migration or transformation doesn't wipe your database—just restart the service and fix the code.</p>

  <hr />

  <h2>Who Should Care About This?</h2>

  <p><strong>Data Engineers:</strong> Separation, migrations, orchestration. Standard patterns.</p>
  <p><strong>Analytics Engineers:</strong> dbt workflows, tests, incremental patterns. Production realities.</p>
  <p><strong>Data Analysts:</strong> Clean, understood inputs that reduce ad-hoc fixes.</p>

  <p>These choices show up across teams. Learn them now to avoid later complexity.</p>

  <hr />

  <h2>What you'll learn by poking around</h2>
  <p>SQL isn’t just SELECTs. Production work adds:</p>
  <ul>
    <li><strong>Incremental models and safe rebuilds</strong> to avoid timeouts and costs</li>
    <li><strong>Tests before deploy</strong> to catch issues early</li>
    <li><strong>Automated maintenance</strong> to keep planner stats current</li>
    <li><strong>Separated logic</strong> to ease changes</li>
    <li><strong>Version control and docs</strong> to keep knowledge current</li>
  </ul>
  <p>This stack isn’t theory; it’s how production systems are built.</p>

  <div class="note">
    <strong>Note</strong>
    <ul>
      <li>This is a demonstration setup and learning guide.</li>
      <li>Tables start empty by design. Run the setup and explore the structure.</li>
      <li>A sample analytics dashboard built on these models will be added next.</li>
    </ul>
  </div>

  <hr />

  <h2>Where to take it next</h2>
  <p>If this resonates, fork the repo, bring your own data, and adapt it. Pick patterns that fit your domain:</p>
  <ul>
    <li>Dimensions, partitioning, late-arriving logic</li>
    <li>Broader tests and macros</li>
    <li>Orchestration scheduling and monitoring</li>
    <li>Staging for multiple sources and ID mapping</li>
  </ul>

  <p>You’ll start building pipelines the way production systems are built—layers, tests, and automation—not ad-hoc scripts. If you want the deeper "why," read <em>Beyond SELECT: SQL as a Full Development Platform</em> (<a href="https://www.megpatakota.co.uk/articles/sql-beyond-select.html" target="_blank" rel="noopener noreferrer">link</a>). Then fork the repo, explore, and adapt it to your needs.</p>

</body>
</html>
